const Heap = require('../dist/heap.js');

class AStar {
    constructor(heurFn, goalFn, succFn, costFn) {
        this.heurFn = heurFn;
        this.goalFn = goalFn;
        this.succFn = succFn;
        this.costFn = costFn;
    }

    _nodeify(data, prev = null) {
        data._astar_data = {
            g: this.costFn(data),
            h: this.heurFn(data, this.start),
            prev: prev };
        return data;
    }

    _step() {
        let current = this.open.pop();
        this.closed.push(current);

        if (this.goalFn(current)) {
            return this.traceback(current);
        }

        this.succFn(current).forEach(successor => {
            if (this.closed.indexOf(successor) < 0) {
                if (this.open.contains(successor)) {
                    let tempCost = current._astar_data.g + successor._astar_data.g;
                    if (tempCost < successor._astar_data.g) {
                        successor._astar_data.g = tempCost;
                        successor._astar_data.prev = current;
                    }
                } else {
                    this.open.push(this._nodeify(successor, current));
                }
            }
        });

        if (this.open.size() == 0) {
            return [];
        }

        return this._step();
    }

    find(start) {
        this.start = start;
        this.open = new Heap(node => node._astar_data.g + node._astar_data.h);
        this.closed = [];

        this.open.push(this._nodeify(this.start));
        return this._step();
    }

    traceback(goal) {
        let path = [goal];
        let trace = node => {
            if (node._astar_data.prev) {
                path.push(node._astar_data.prev);
                trace(node._astar_data.prev);
            }
        };
        trace(goal);
        path.reverse();
        return path.map(node => {
            delete node._astar_data;
            return node;
        });
    }
}

module.exports = AStar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvYXN0YXIuanN5Il0sIm5hbWVzIjpbIkhlYXAiLCJyZXF1aXJlIiwiQVN0YXIiLCJjb25zdHJ1Y3RvciIsImhldXJGbiIsImdvYWxGbiIsInN1Y2NGbiIsImNvc3RGbiIsIl9ub2RlaWZ5IiwiZGF0YSIsInByZXYiLCJfYXN0YXJfZGF0YSIsImciLCJoIiwic3RhcnQiLCJfc3RlcCIsImN1cnJlbnQiLCJvcGVuIiwicG9wIiwiY2xvc2VkIiwicHVzaCIsInRyYWNlYmFjayIsImZvckVhY2giLCJzdWNjZXNzb3IiLCJpbmRleE9mIiwiY29udGFpbnMiLCJ0ZW1wQ29zdCIsInNpemUiLCJmaW5kIiwibm9kZSIsImdvYWwiLCJwYXRoIiwidHJhY2UiLCJyZXZlcnNlIiwibWFwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsT0FBT0MsUUFBVSxpQkFBVixDQUFiOztBQUVBLE1BQU1DLEtBQU4sQ0FBWTtBQUNSQyxnQkFBYUMsTUFBYixFQUFxQkMsTUFBckIsRUFBNkJDLE1BQTdCLEVBQXFDQyxNQUFyQyxFQUE4QztBQUMxQyxhQUFLSCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFBb0I7O0FBRXhCQyxhQUFVQyxJQUFWLEVBQWdCQyxPQUFLLElBQXJCLEVBQTRCO0FBQ3hCRCxhQUFLRSxXQUFMLEdBQW1CO0FBQ2ZDLGVBQUcsS0FBS0wsTUFBTCxDQUFhRSxJQUFiLENBRFk7QUFFZkksZUFBRyxLQUFLVCxNQUFMLENBQWFLLElBQWIsRUFBbUIsS0FBS0ssS0FBeEIsQ0FGWTtBQUdmSixrQkFBTUEsSUFIUyxFQUFuQjtBQUlBLGVBQU9ELElBQVA7QUFBVzs7QUFFZk0sWUFBUTtBQUNKLFlBQUlDLFVBQVUsS0FBS0MsSUFBTCxDQUFVQyxHQUFWLEVBQWQ7QUFDQSxhQUFLQyxNQUFMLENBQVlDLElBQVosQ0FBbUJKLE9BQW5COztBQUVBLFlBQUcsS0FBS1gsTUFBTCxDQUFjVyxPQUFkLENBQUgsRUFBMkI7QUFBQyxtQkFBTyxLQUFLSyxTQUFMLENBQWlCTCxPQUFqQixDQUFQO0FBQStCOztBQUUzRCxhQUFLVixNQUFMLENBQWFVLE9BQWIsRUFBdUJNLE9BQXZCLENBQWlDQyxhQUFhO0FBQzFDLGdCQUFHLEtBQUtKLE1BQUwsQ0FBWUssT0FBWixDQUFxQkQsU0FBckIsSUFBbUMsQ0FBdEMsRUFBMEM7QUFDdEMsb0JBQUcsS0FBS04sSUFBTCxDQUFVUSxRQUFWLENBQXFCRixTQUFyQixDQUFILEVBQW9DO0FBQ2hDLHdCQUFJRyxXQUFXVixRQUFRTCxXQUFSLENBQW9CQyxDQUFwQixHQUF3QlcsVUFBVVosV0FBVixDQUFzQkMsQ0FBN0Q7QUFDQSx3QkFBR2MsV0FBV0gsVUFBVVosV0FBVixDQUFzQkMsQ0FBcEMsRUFBd0M7QUFDcENXLGtDQUFVWixXQUFWLENBQXNCQyxDQUF0QixHQUEwQmMsUUFBMUI7QUFDQUgsa0NBQVVaLFdBQVYsQ0FBc0JELElBQXRCLEdBQTZCTSxPQUE3QjtBQUFvQztBQUFBLGlCQUo1QyxNQUtLO0FBQ0QseUJBQUtDLElBQUwsQ0FBVUcsSUFBVixDQUFpQixLQUFLWixRQUFMLENBQWdCZSxTQUFoQixFQUEyQlAsT0FBM0IsQ0FBakI7QUFBbUQ7QUFBQTtBQUFBLFNBUi9EOztBQVVBLFlBQUcsS0FBS0MsSUFBTCxDQUFVVSxJQUFWLE1BQW9CLENBQXZCLEVBQTJCO0FBQUMsbUJBQU8sRUFBUDtBQUFTOztBQUVyQyxlQUFPLEtBQUtaLEtBQUwsRUFBUDtBQUFtQjs7QUFFdkJhLFNBQU1kLEtBQU4sRUFBYztBQUNWLGFBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLGFBQUtHLElBQUwsR0FBWSxJQUFJakIsSUFBSixDQUFhNkIsSUFBRixJQUFZQSxLQUFLbEIsV0FBTCxDQUFpQkMsQ0FBakIsR0FBcUJpQixLQUFLbEIsV0FBTCxDQUFpQkUsQ0FBN0QsQ0FBWjtBQUNBLGFBQUtNLE1BQUwsR0FBYyxFQUFkOztBQUVBLGFBQUtGLElBQUwsQ0FBVUcsSUFBVixDQUFpQixLQUFLWixRQUFMLENBQWdCLEtBQUtNLEtBQXJCLENBQWpCO0FBQ0EsZUFBTyxLQUFLQyxLQUFMLEVBQVA7QUFBbUI7O0FBRXZCTSxjQUFXUyxJQUFYLEVBQWtCO0FBQ2QsWUFBSUMsT0FBTyxDQUFFRCxJQUFGLENBQVg7QUFDQSxZQUFJRSxRQUFVSCxJQUFGLElBQVk7QUFDcEIsZ0JBQUdBLEtBQUtsQixXQUFMLENBQWlCRCxJQUFwQixFQUEyQjtBQUN2QnFCLHFCQUFLWCxJQUFMLENBQVlTLEtBQUtsQixXQUFMLENBQWlCRCxJQUE3QjtBQUNBc0Isc0JBQVFILEtBQUtsQixXQUFMLENBQWlCRCxJQUF6QjtBQUE2QjtBQUFBLFNBSHJDO0FBSUFzQixjQUFRRixJQUFSO0FBQ0FDLGFBQUtFLE9BQUw7QUFDQSxlQUFPRixLQUFLRyxHQUFMLENBQWFMLElBQUYsSUFBWTtBQUMxQixtQkFBT0EsS0FBS2xCLFdBQVo7QUFDQSxtQkFBT2tCLElBQVA7QUFBVyxTQUZSLENBQVA7QUFFZTtBQXBEWDs7QUF1RFpNLE9BQU9DLE9BQVAsR0FBaUJsQyxLQUFqQiIsImZpbGUiOiJhc3Rhci5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhlYXAgPSByZXF1aXJlIEAgJy4uL2Rpc3QvaGVhcC5qcydcblxuY2xhc3MgQVN0YXIgOjpcbiAgICBjb25zdHJ1Y3RvciggaGV1ckZuLCBnb2FsRm4sIHN1Y2NGbiwgY29zdEZuICkgOjpcbiAgICAgICAgdGhpcy5oZXVyRm4gPSBoZXVyRm5cbiAgICAgICAgdGhpcy5nb2FsRm4gPSBnb2FsRm5cbiAgICAgICAgdGhpcy5zdWNjRm4gPSBzdWNjRm5cbiAgICAgICAgdGhpcy5jb3N0Rm4gPSBjb3N0Rm5cblxuICAgIF9ub2RlaWZ5KCBkYXRhLCBwcmV2PW51bGwgKSA6OlxuICAgICAgICBkYXRhLl9hc3Rhcl9kYXRhID0gOjpcbiAgICAgICAgICAgIGc6IHRoaXMuY29zdEZuKCBkYXRhICksXG4gICAgICAgICAgICBoOiB0aGlzLmhldXJGbiggZGF0YSwgdGhpcy5zdGFydCApLFxuICAgICAgICAgICAgcHJldjogcHJldlxuICAgICAgICByZXR1cm4gZGF0YVxuXG4gICAgX3N0ZXAoKSA6OlxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMub3Blbi5wb3AoKVxuICAgICAgICB0aGlzLmNsb3NlZC5wdXNoIEAgY3VycmVudFxuXG4gICAgICAgIGlmIHRoaXMuZ29hbEZuIEAgY3VycmVudCA6OiByZXR1cm4gdGhpcy50cmFjZWJhY2sgQCBjdXJyZW50XG5cbiAgICAgICAgdGhpcy5zdWNjRm4oIGN1cnJlbnQgKS5mb3JFYWNoIEAgc3VjY2Vzc29yID0+IDo6XG4gICAgICAgICAgICBpZiB0aGlzLmNsb3NlZC5pbmRleE9mKCBzdWNjZXNzb3IgKSA8IDAgOjpcbiAgICAgICAgICAgICAgICBpZiB0aGlzLm9wZW4uY29udGFpbnMgQCBzdWNjZXNzb3IgOjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBDb3N0ID0gY3VycmVudC5fYXN0YXJfZGF0YS5nICsgc3VjY2Vzc29yLl9hc3Rhcl9kYXRhLmdcbiAgICAgICAgICAgICAgICAgICAgaWYgdGVtcENvc3QgPCBzdWNjZXNzb3IuX2FzdGFyX2RhdGEuZyA6OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yLl9hc3Rhcl9kYXRhLmcgPSB0ZW1wQ29zdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yLl9hc3Rhcl9kYXRhLnByZXYgPSBjdXJyZW50XG4gICAgICAgICAgICAgICAgZWxzZSA6OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4ucHVzaCBAIHRoaXMuX25vZGVpZnkgQCBzdWNjZXNzb3IsIGN1cnJlbnRcblxuICAgICAgICBpZiB0aGlzLm9wZW4uc2l6ZSgpID09IDAgOjogcmV0dXJuIFtdXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXAoKVxuXG4gICAgZmluZCggc3RhcnQgKSA6OlxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEhlYXAgQCAoIG5vZGUgKSA9PiBub2RlLl9hc3Rhcl9kYXRhLmcgKyBub2RlLl9hc3Rhcl9kYXRhLmhcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBbXVxuXG4gICAgICAgIHRoaXMub3Blbi5wdXNoIEAgdGhpcy5fbm9kZWlmeSBAIHRoaXMuc3RhcnRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXAoKVxuICAgICAgICBcbiAgICB0cmFjZWJhY2soIGdvYWwgKSA6OlxuICAgICAgICBsZXQgcGF0aCA9IFsgZ29hbCBdXG4gICAgICAgIGxldCB0cmFjZSA9ICggbm9kZSApID0+IDo6XG4gICAgICAgICAgICBpZiBub2RlLl9hc3Rhcl9kYXRhLnByZXYgOjpcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2ggQCBub2RlLl9hc3Rhcl9kYXRhLnByZXZcbiAgICAgICAgICAgICAgICB0cmFjZSBAIG5vZGUuX2FzdGFyX2RhdGEucHJldlxuICAgICAgICB0cmFjZSBAIGdvYWxcbiAgICAgICAgcGF0aC5yZXZlcnNlKClcbiAgICAgICAgcmV0dXJuIHBhdGgubWFwIEAgKCBub2RlICkgPT4gOjpcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9hc3Rhcl9kYXRhXG4gICAgICAgICAgICByZXR1cm4gbm9kZVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQVN0YXJcbiJdfQ==