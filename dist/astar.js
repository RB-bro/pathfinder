const Heap = require('../dist/heap.js');

class AStar {
    constructor(heurFn, goalFn, succFn, costFn) {
        this.heurFn = heurFn;
        this.goalFn = goalFn;
        this.succFn = succFn;
        this.costFn = costFn;
    }

    _nodeify(data, prev = null) {
        data._astar_data = {
            g: this.costFn(data),
            h: this.heurFn(data, this.start),
            prev: prev };
        return data;
    }

    _step() {
        let current = this.open.pop();
        this.closed.push(current);

        if (this.goalFn(current)) {
            return this.traceback(current);
        }

        this.succFn(current).forEach(successor => {
            if (this.closed.indexOf(successor) < 0) {
                if (this.open.contains(successor)) {
                    let tempCost = current._astar_data.g + successor._astar_data.g;
                    if (tempCost < successor._astar_data.g) {
                        successor._astar_data.g = tempCost;
                        successor._astar_data.prev = current;
                    }
                } else {
                    this.open.push(this._nodeify(successor, current));
                }
            }
        });

        if (this.open.size() == 0) {
            return [];
        }

        return this._step();
    }

    find(start) {
        this.start = start;
        this.open = new Heap(node => node._astar_data.g + node._astar_data.h);
        this.closed = [];

        this.open.push(this._nodeify(this.start));
        return this._step();
    }

    traceback(goal) {
        let path = [goal];
        let trace = node => {
            if (node._astar_data.prev) {
                path.push(node._astar_data.prev);
                trace(node._astar_data.prev);
            }
        };
        trace(goal);
        path.reverse();
        return path.map(node => {
            delete node._astar_data;
            return node;
        });
    }
}

module.exports = AStar;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvYXN0YXIuanN5Il0sIm5hbWVzIjpbIkhlYXAiLCJyZXF1aXJlIiwiQVN0YXIiLCJjb25zdHJ1Y3RvciIsImhldXJGbiIsImdvYWxGbiIsInN1Y2NGbiIsImNvc3RGbiIsIl9ub2RlaWZ5IiwiZGF0YSIsInByZXYiLCJfYXN0YXJfZGF0YSIsImciLCJoIiwic3RhcnQiLCJfc3RlcCIsImN1cnJlbnQiLCJvcGVuIiwicG9wIiwiY2xvc2VkIiwicHVzaCIsInRyYWNlYmFjayIsImZvckVhY2giLCJzdWNjZXNzb3IiLCJpbmRleE9mIiwiY29udGFpbnMiLCJ0ZW1wQ29zdCIsInNpemUiLCJmaW5kIiwibm9kZSIsImdvYWwiLCJwYXRoIiwidHJhY2UiLCJyZXZlcnNlIiwibWFwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsT0FBT0MsUUFBVSxpQkFBVixDQUFiOztBQUVBLE1BQU1DLEtBQU4sQ0FBWTtBQUNSQyxnQkFBYUMsTUFBYixFQUFxQkMsTUFBckIsRUFBNkJDLE1BQTdCLEVBQXFDQyxNQUFyQyxFQUE4QztBQUMxQyxhQUFLSCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFBb0I7O0FBRXhCQyxhQUFVQyxJQUFWLEVBQWdCQyxPQUFLLElBQXJCLEVBQTRCO0FBQ3hCRCxhQUFLRSxXQUFMLEdBQW1CO0FBQ2ZDLGVBQUcsS0FBS0wsTUFBTCxDQUFhRSxJQUFiLENBRFk7QUFFYkksZUFBRyxLQUFLVCxNQUFMLENBQWFLLElBQWIsRUFBbUIsS0FBS0ssS0FBeEIsQ0FGVTtBQUdiSixrQkFBTUEsSUFITyxFQUFuQjtBQUlBLGVBQU9ELElBQVA7QUFBVzs7QUFFZk0sWUFBUTtBQUNKLFlBQUlDLFVBQVUsS0FBS0MsSUFBTCxDQUFVQyxHQUFWLEVBQWQ7QUFDQSxhQUFLQyxNQUFMLENBQVlDLElBQVosQ0FBbUJKLE9BQW5COztBQUVBLFlBQUcsS0FBS1gsTUFBTCxDQUFjVyxPQUFkLENBQUgsRUFBMkI7QUFBQyxtQkFBTyxLQUFLSyxTQUFMLENBQWlCTCxPQUFqQixDQUFQO0FBQStCOztBQUUzRCxhQUFLVixNQUFMLENBQWFVLE9BQWIsRUFBdUJNLE9BQXZCLENBQWlDQyxhQUFhO0FBQzFDLGdCQUFHLEtBQUtKLE1BQUwsQ0FBWUssT0FBWixDQUFxQkQsU0FBckIsSUFBbUMsQ0FBdEMsRUFBMEM7QUFDdEMsb0JBQUcsS0FBS04sSUFBTCxDQUFVUSxRQUFWLENBQXFCRixTQUFyQixDQUFILEVBQW9DO0FBQ2hDLHdCQUFJRyxXQUFXVixRQUFRTCxXQUFSLENBQW9CQyxDQUFwQixHQUF3QlcsVUFBVVosV0FBVixDQUFzQkMsQ0FBN0Q7QUFDQSx3QkFBR2MsV0FBV0gsVUFBVVosV0FBVixDQUFzQkMsQ0FBcEMsRUFBd0M7QUFDcENXLGtDQUFVWixXQUFWLENBQXNCQyxDQUF0QixHQUEwQmMsUUFBMUI7QUFDQUgsa0NBQVVaLFdBQVYsQ0FBc0JELElBQXRCLEdBQTZCTSxPQUE3QjtBQUFvQztBQUFBLGlCQUo1QyxNQUtLO0FBQ0QseUJBQUtDLElBQUwsQ0FBVUcsSUFBVixDQUFpQixLQUFLWixRQUFMLENBQWdCZSxTQUFoQixFQUEyQlAsT0FBM0IsQ0FBakI7QUFBbUQ7QUFBQTtBQUFBLFNBUi9EOztBQVVBLFlBQUcsS0FBS0MsSUFBTCxDQUFVVSxJQUFWLE1BQW9CLENBQXZCLEVBQTJCO0FBQUMsbUJBQU8sRUFBUDtBQUFTOztBQUVyQyxlQUFPLEtBQUtaLEtBQUwsRUFBUDtBQUFtQjs7QUFFdkJhLFNBQU1kLEtBQU4sRUFBYztBQUNWLGFBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLGFBQUtHLElBQUwsR0FBWSxJQUFJakIsSUFBSixDQUFhNkIsSUFBRixJQUFZQSxLQUFLbEIsV0FBTCxDQUFpQkMsQ0FBakIsR0FBcUJpQixLQUFLbEIsV0FBTCxDQUFpQkUsQ0FBN0QsQ0FBWjtBQUNBLGFBQUtNLE1BQUwsR0FBYyxFQUFkOztBQUVBLGFBQUtGLElBQUwsQ0FBVUcsSUFBVixDQUFpQixLQUFLWixRQUFMLENBQWdCLEtBQUtNLEtBQXJCLENBQWpCO0FBQ0EsZUFBTyxLQUFLQyxLQUFMLEVBQVA7QUFBbUI7O0FBRXZCTSxjQUFXUyxJQUFYLEVBQWtCO0FBQ2QsWUFBSUMsT0FBTyxDQUFFRCxJQUFGLENBQVg7QUFDQSxZQUFJRSxRQUFVSCxJQUFGLElBQVk7QUFDcEIsZ0JBQUdBLEtBQUtsQixXQUFMLENBQWlCRCxJQUFwQixFQUEyQjtBQUN2QnFCLHFCQUFLWCxJQUFMLENBQVlTLEtBQUtsQixXQUFMLENBQWlCRCxJQUE3QjtBQUNBc0Isc0JBQVFILEtBQUtsQixXQUFMLENBQWlCRCxJQUF6QjtBQUE2QjtBQUFBLFNBSHJDO0FBSUFzQixjQUFRRixJQUFSO0FBQ0FDLGFBQUtFLE9BQUw7QUFDQSxlQUFPRixLQUFLRyxHQUFMLENBQWFMLElBQUYsSUFBWTtBQUMxQixtQkFBT0EsS0FBS2xCLFdBQVo7QUFDQSxtQkFBT2tCLElBQVA7QUFBVyxTQUZSLENBQVA7QUFFZTtBQXBEWDs7QUF1RFpNLE9BQU9DLE9BQVAsR0FBaUJsQyxLQUFqQiIsImZpbGUiOiJhc3Rhci5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhlYXAgPSByZXF1aXJlIEAgJy4uL2Rpc3QvaGVhcC5qcydcblxuY2xhc3MgQVN0YXIgOjpcbiAgICBjb25zdHJ1Y3RvciggaGV1ckZuLCBnb2FsRm4sIHN1Y2NGbiwgY29zdEZuICkgOjpcbiAgICAgICAgdGhpcy5oZXVyRm4gPSBoZXVyRm5cbiAgICAgICAgdGhpcy5nb2FsRm4gPSBnb2FsRm5cbiAgICAgICAgdGhpcy5zdWNjRm4gPSBzdWNjRm5cbiAgICAgICAgdGhpcy5jb3N0Rm4gPSBjb3N0Rm5cblxuICAgIF9ub2RlaWZ5KCBkYXRhLCBwcmV2PW51bGwgKSA6OlxuICAgICAgICBkYXRhLl9hc3Rhcl9kYXRhID0gOjpcbiAgICAgICAgICAgIGc6IHRoaXMuY29zdEZuKCBkYXRhIClcbiAgICAgICAgICAgICwgaDogdGhpcy5oZXVyRm4oIGRhdGEsIHRoaXMuc3RhcnQgKVxuICAgICAgICAgICAgLCBwcmV2OiBwcmV2XG4gICAgICAgIHJldHVybiBkYXRhXG5cbiAgICBfc3RlcCgpIDo6XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5vcGVuLnBvcCgpXG4gICAgICAgIHRoaXMuY2xvc2VkLnB1c2ggQCBjdXJyZW50XG5cbiAgICAgICAgaWYgdGhpcy5nb2FsRm4gQCBjdXJyZW50IDo6IHJldHVybiB0aGlzLnRyYWNlYmFjayBAIGN1cnJlbnRcblxuICAgICAgICB0aGlzLnN1Y2NGbiggY3VycmVudCApLmZvckVhY2ggQCBzdWNjZXNzb3IgPT4gOjpcbiAgICAgICAgICAgIGlmIHRoaXMuY2xvc2VkLmluZGV4T2YoIHN1Y2Nlc3NvciApIDwgMCA6OlxuICAgICAgICAgICAgICAgIGlmIHRoaXMub3Blbi5jb250YWlucyBAIHN1Y2Nlc3NvciA6OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcENvc3QgPSBjdXJyZW50Ll9hc3Rhcl9kYXRhLmcgKyBzdWNjZXNzb3IuX2FzdGFyX2RhdGEuZ1xuICAgICAgICAgICAgICAgICAgICBpZiB0ZW1wQ29zdCA8IHN1Y2Nlc3Nvci5fYXN0YXJfZGF0YS5nIDo6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzb3IuX2FzdGFyX2RhdGEuZyA9IHRlbXBDb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzb3IuX2FzdGFyX2RhdGEucHJldiA9IGN1cnJlbnRcbiAgICAgICAgICAgICAgICBlbHNlIDo6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi5wdXNoIEAgdGhpcy5fbm9kZWlmeSBAIHN1Y2Nlc3NvciwgY3VycmVudFxuXG4gICAgICAgIGlmIHRoaXMub3Blbi5zaXplKCkgPT0gMCA6OiByZXR1cm4gW11cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcCgpXG5cbiAgICBmaW5kKCBzdGFydCApIDo6XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydFxuICAgICAgICB0aGlzLm9wZW4gPSBuZXcgSGVhcCBAICggbm9kZSApID0+IG5vZGUuX2FzdGFyX2RhdGEuZyArIG5vZGUuX2FzdGFyX2RhdGEuaFxuICAgICAgICB0aGlzLmNsb3NlZCA9IFtdXG5cbiAgICAgICAgdGhpcy5vcGVuLnB1c2ggQCB0aGlzLl9ub2RlaWZ5IEAgdGhpcy5zdGFydFxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcCgpXG4gICAgICAgIFxuICAgIHRyYWNlYmFjayggZ29hbCApIDo6XG4gICAgICAgIGxldCBwYXRoID0gWyBnb2FsIF1cbiAgICAgICAgbGV0IHRyYWNlID0gKCBub2RlICkgPT4gOjpcbiAgICAgICAgICAgIGlmIG5vZGUuX2FzdGFyX2RhdGEucHJldiA6OlxuICAgICAgICAgICAgICAgIHBhdGgucHVzaCBAIG5vZGUuX2FzdGFyX2RhdGEucHJldlxuICAgICAgICAgICAgICAgIHRyYWNlIEAgbm9kZS5fYXN0YXJfZGF0YS5wcmV2XG4gICAgICAgIHRyYWNlIEAgZ29hbFxuICAgICAgICBwYXRoLnJldmVyc2UoKVxuICAgICAgICByZXR1cm4gcGF0aC5tYXAgQCAoIG5vZGUgKSA9PiA6OlxuICAgICAgICAgICAgZGVsZXRlIG5vZGUuX2FzdGFyX2RhdGFcbiAgICAgICAgICAgIHJldHVybiBub2RlXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBU3RhclxuIl19